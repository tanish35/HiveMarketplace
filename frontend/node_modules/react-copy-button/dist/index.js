'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var tslib = require('tslib');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespace(React);

var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
/**
 * Copy text to clipboard.
 *
 * @param  {string} text
 * @returns Promise
 */
function copyTextToClipboard(text) {
  return tslib.__awaiter(this, void 0, void 0, function () {
    return tslib.__generator(this, function (_a) {
      switch (_a.label) {
        case 0:
          if (!navigator.clipboard) return [3 /*break*/, 2];
          return [4 /*yield*/, navigator.clipboard.writeText(text)];
        case 1:
          _a.sent();
          return [3 /*break*/, 3];
        case 2:
          copyTextLegacy(text);
          _a.label = 3;
        case 3:
          return [2 /*return*/];
      }
    });
  });
}
/**
 * Convert image to return Blob object before writing it to the clipboard.
 *
 * @param  {string} url
 * @returns {Promise<Blob}
 */
function getImageBlobFromUrl(url) {
  return tslib.__awaiter(this, void 0, void 0, function () {
    var data, blob;
    return tslib.__generator(this, function (_a) {
      switch (_a.label) {
        case 0:
          return [4 /*yield*/, fetch(url)];
        case 1:
          data = _a.sent();
          return [4 /*yield*/, data.blob()];
        case 2:
          blob = _a.sent();
          return [2 /*return*/, blob];
      }
    });
  });
}
/**
 * Only 'text/plain' and 'image/png' are implemented in both Chrome and Safari.
 * This is workaround for SVGs, as they can be copied as 'text/plain'
 * instead of 'image/svg+xml'.
 *
 * @param  {string} url
 * @returns {Promise<Blob}
 */
function getTextBlobFromUrl(url) {
  return tslib.__awaiter(this, void 0, void 0, function () {
    var response, source;
    return tslib.__generator(this, function (_a) {
      switch (_a.label) {
        case 0:
          return [4 /*yield*/, fetch(url)];
        case 1:
          response = _a.sent();
          return [4 /*yield*/, response.text()];
        case 2:
          source = _a.sent();
          return [2 /*return*/, new Blob([source], {
            type: 'text/plain'
          })];
      }
    });
  });
}
/**
 * Copy image to clipboard.
 *
 * Chromium browsers require a Blob type when you create a
 * new ClipboardItem e.g. {'<IMAGE MIME TYPE>': Blob},
 * Safari on the other hand requires an unresolved Promise
 * that returns a Blob object e.g. {'<IMAGE MIME TYPE>': Promise<Blob>}.
 *
 * @param  {string} url
 * @param  {HTMLDivElement} element
 * @returns {Promise<void>}
 */
function copyImageToClipboard(content) {
  return tslib.__awaiter(this, void 0, void 0, function () {
    var mimeType, _a, blobPromise, clipboardObject, _b;
    var _c, _d;
    return tslib.__generator(this, function (_e) {
      switch (_e.label) {
        case 0:
          if (content instanceof HTMLDivElement) {
            copyImageLegacy(content);
            return [2 /*return*/];
          }

          if (!navigator.clipboard) return [3 /*break*/, 7];
          if (!isSafari) return [3 /*break*/, 1];
          _a = {
            type: 'image/png'
          };
          return [3 /*break*/, 3];
        case 1:
          return [4 /*yield*/, getImageBlobFromUrl(content)];
        case 2:
          _a = _e.sent();
          _e.label = 3;
        case 3:
          mimeType = _a.type;
          blobPromise = mimeType === 'image/svg' ? getTextBlobFromUrl(content) : getImageBlobFromUrl(content);
          clipboardObject = void 0;
          if (!isSafari) return [3 /*break*/, 4];
          clipboardObject = (_c = {}, _c[mimeType] = blobPromise, _c);
          return [3 /*break*/, 6];
        case 4:
          _d = {};
          _b = mimeType;
          return [4 /*yield*/, blobPromise];
        case 5:
          clipboardObject = (_d[_b] = _e.sent(), _d);
          _e.label = 6;
        case 6:
          navigator.clipboard.write([new window.ClipboardItem(clipboardObject)]).catch(function (err) {
            return console.warn("Image not supported.", err);
          });
          return [2 /*return*/];
        case 7:
          console.warn("'navigator.clipboard' is not supported in this browser. Pass element instead.");
          return [2 /*return*/];
      }
    });
  });
}
/**
 * Copies given text to clipboard. It creates textarea element and sets given text to value, appends the
 * element to HTML document outside the screen to make it invisible and copies the selected text from
 * textarea element. Also it checks for previously selected content. If a selection existed before
 * copying, it unselects everything on the HTML document restores the original selection.
 *
 * @param {string} text
 * @returns {any}
 */
function copyTextLegacy(text) {
  // IE specific code path to prevent textarea being shown while dialog is visible.
  if (window.clipboardData && window.clipboardData.setData) {
    return window.clipboardData.setData('Text', text);
  }
  if (document.queryCommandSupported && document.queryCommandSupported('copy')) {
    var selectionArea = document.getSelection();
    var element = document.createElement('textarea');
    element.textContent = text;
    element.style.left = '-9999px';
    // Fixed Prevent scrolling to bottom of page in MS Edge.
    element.style.position = 'fixed';
    element.setAttribute('readonly', '');
    document.body.appendChild(element);
    element.select();
    element.focus();
    try {
      return document.execCommand('copy'); // Security exception may be thrown by some browsers.
    } catch (ex) {
      console.warn('Copy to clipboard failed.', ex);
      return false;
    } finally {
      document.body.removeChild(element);
      if (selectionArea) {
        var selected = selectionArea.rangeCount > 0 ? selectionArea.getRangeAt(0) : false;
        if (selected) {
          selectionArea.removeAllRanges();
          selectionArea.addRange(selected);
        }
      }
    }
  }
}
/**
 * Copies given image containing element to clipboard.
 * The image element should be wrapped with div.
 *
 * @param {HTMLDivElement} element
 * @returns {boolean}
 */
function copyImageLegacy(element) {
  var selection = window.getSelection();
  var range = document.createRange();
  if (!selection) {
    return false;
  }
  range.selectNodeContents(element);
  selection.removeAllRanges();
  selection.addRange(range);
  try {
    return document.execCommand('copy'); // Security exception may be thrown by some browsers.
  } catch (ex) {
    console.warn('Copy to clipboard failed.', ex);
    return false;
  } finally {
    selection.removeAllRanges();
  }
}

var CopyButton = function CopyButton(props) {
  var text = props.text,
    imageURL = props.imageURL,
    imageRef = props.imageRef,
    className = props.className,
    children = props.children;
  var handleClick = function handleClick() {
    if (text !== undefined) {
      copyTextToClipboard(text);
    }
    var content = imageURL || (imageRef === null || imageRef === void 0 ? void 0 : imageRef.current);
    if (content) {
      copyImageToClipboard(content);
    }
    props.onCopy && props.onCopy();
  };
  return /*#__PURE__*/React__namespace.createElement("button", {
    type: "button",
    className: className,
    onClick: handleClick
  }, children);
};
var CopyButton$1 = CopyButton;

exports.CopyButton = CopyButton$1;
//# sourceMappingURL=index.js.map
